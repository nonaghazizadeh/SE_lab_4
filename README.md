<head>
  <link rel="stylesheet" type="text/css" href="styles.css">
</head>

<div>
<h2>گزارش آزمایش چهارم مهندسی نرم‌افزار
</h2>
<h3>رضا عبداله‌زاده ۹۷۱۰۶۱۳۲ 
<br>
نونا قاضی‌زاده ۹۸۱۷۱۰۰۷
</h3>

<br><br><br>
<b>بخش اول</b>

در این بخش، ابتدا فایل javacup را بدون بهینه‌سازی اجرا کرده و در yourkit وضعیت مصرف منابع آن‌ و بخش‌هایی از قطعه کد که بیشترین مصرف را ایجاد می‌کنند، بررسی میکنیم.

اسکرین‌شات‌های زیر به ترتیب این مراحل را نشان میدهند:

- خروجی اجرای کد به ازای ورودی 1,2,3 ("No")
![iamge](assets/Screenshot%201402-02-08%20at%2013.03.45.png)
- رسیدن cpu به یک قله پیش از دادن ورودی
![image](assets/Screenshot%201402-02-08%20at%2012.55.02.png)
- رسیدن cpu به یک قله پس از دادن ورودی و مصرف بیش از حد منابع
![image](assets/Screenshot%201402-02-08%20at%2012.55.55.png)
- وضعیت memory پیش از پیک زدن
![image](assets/Screenshot%201402-02-08%20at%2012.57.40.png)
- وضعیت memory در قله پس از دادن ورودی
![image](assets/Screenshot%201402-02-08%20at%2012.58.22.png)
- call tree در نقطه‌ی قله‌ی مصرف منابع. همانطور که مشخص است متد temp بیشترین مصرف را هم از لحاظ مصرف و هم از لحاظ runtime دارد.
![](assets/Screenshot%201402-02-08%20at%2012.59.16.png)
- call tree با در نظر گرفتن ترد‌ها روی قله
![](assets/Screenshot%201402-02-08%20at%2013.02.21.png)


حال کد فانکشن temp را که یک حلقه for تو در تو است را بهینه میکنیم
به طوری که به جای استفاده از ArrayList از آرایه built-in جاوا استفاده کند.
با اینکار مصرف منابع بسیار کاهش میابد به طوری که هیچ قله‌ی بزرگی در نمودار مصرف memory و استفاده از cpu مشاهده نمی‌شود و میزان runtime در تابع temp به چند میلی ثانیه کاهش میابد.
کد حاصل را در فایل `javaCupO.java` ذخیره می‌کنیم.
کد temp تغییر یافته به صورت زیر است:
<pre style="direction: ltr;">
<code style="direction: ltr;">
public static void temp() {
  int[] a = new int[20000 * 10000];
  int index = 0;
   for (int i = 0; i < 10000; i++) {
       for (int j = 0; j < 20000; j++) {
           a[index++] = i + j;
        }
    }
}
</code>
</pre>
- ورودی دادن 1,2,3 و خروجی "No"
![](assets/Screenshot%201402-02-08%20at%2013.13.17.png)
- نمودار cpu پیش از دادن ورودی
![](assets/Screenshot%201402-02-08%20at%2013.06.38.png)
- نمودار cpu پس از دادن ورودی. هیچ قله‌ای مشاهده نمی‌شود و خروجی در لحظه محاسبه می‌شود.
![](assets/Screenshot%201402-02-08%20at%2013.07.17.png)
- نمودار memory پیش از دادن ورودی
![](assets/Screenshot%201402-02-08%20at%2013.08.57.png)
- نمودار memory پس از دادن ورودی
![](assets/Screenshot%201402-02-08%20at%2013.09.17.png)
- call tree در انتها
![](assets/Screenshot%201402-02-08%20at%2013.11.28.png)
- call tree به همراه ترد‌ها.
![](assets/Screenshot%201402-02-08%20at%2013.12.20.png)

<b>بخش دوم</b>

کد پیاده‌سازی شده به ازای یک ماتریس باید به تعداد دلخواه ضرب این ماتریس در خودش را حساب کند. در این آزمایش ما به ازای ماتریس 

<table>
  <tr>
    <td>1</td>
    <td>2</td>
  </tr>
  <tr>
    <td>3</td>
    <td>4</td>
  </tr>
</table>

حاصل ضرب آن در خودش به تعداد ۲ به توان ۲۷ بار را محاسبه میکنیم. 
در حالت غیر بهینه این ماتریس را به همین تعداد در ماتریسی که در بالا مشخص شده است ضرب میکنیم.
این کد در `Sample.java` ذخیره میکنیم.

اسکرین‌شات‌های زیر مراحل را به ترتیب نشان می‌دهند:
- حاصل خروجی کد به ازای ۲ به توان ۲۷ بار ضرب در خود 
![](assets/Screenshot%201402-02-08%20at%2013.23.23.png)
- قله‌ی مصرف cpu
![](assets/Screenshot%201402-02-08%20at%2013.17.59.png)
- قله‌ی مصرف memory
![](assets/Screenshot%201402-02-08%20at%2013.19.16.png)
- لیست call tree. همانطور که مشخص است، فانکشن powerMatrix بیشترین مصرف و بیشترین runtime را دارد.
![](assets/Screenshot%201402-02-08%20at%2013.20.27.png)
- لیست call tree به همراه ترد
![](assets/Screenshot%201402-02-08%20at%2013.21.49.png)


کد قبل را به نحوی بهینه میکنیم که به جای ۲ به توان ۲۷ بار، ۲۷ بار ماتریس را در خودش ضرب میکنیم. کد حاصل را در `SampleO.java` ذخیره میکنیم. طبق نمودار‌ها مصرف منابع و  runtime بسیار کاهش یافته است.
لازم به ذکر است به منظور مشاهده نمودارها از آنجایی که این برنامه لحظه‌ای پایان می‌یابد، توان یعنی عدد ۲۷ را از ورودی می‌گیریم که صرفا نمایی از مصرف cpu و memory را داشته باشسیم.
کد تغییر یافته powerMatrix به صورت زیراست:
<pre style="direction: ltr;">
<code style="direction: ltr;">
public static long[][] powerMatrix(long[][] matrix, int power) {
  long[][] result = matrix;
      for (int i = 0; i < power; i++) {
          result = multiplyMatrix(result, result);
      }
    return result;
}
</code>
</pre>

مراحل مختلف را در زیر میبینیم:
- تصویر ورودی و خروجی کد
![](assets/Screenshot%201402-02-08%20at%2013.35.09.png)
- پردازش cpu پیش از دادن ورودی
![](assets/Screenshot%201402-02-08%20at%2013.28.55.png)
- پردازش ورودی پس از دادن ورودی. بدلیل بهینه بودن کد، هیچ قله‌ای دیده‌ نمی‌شود و چون متد powerMatrix به صورت آنی اجرا میشود، این متد را در بین متد‌های مشخص شده مشاهده نمیکنیم.
![](assets/Screenshot%201402-02-08%20at%2013.31.01.png)
- مصرف مموری پس از دادن ورودی
![](assets/Screenshot%201402-02-08%20at%2013.32.12.png)
- نمودار call tree. همانطور که مشخص است متد powerMatrix بدلیل runtime بسیار پایین در بین متد‌ها نیست.
![](assets/Screenshot%201402-02-08%20at%2013.34.00.png)
- نمودار call tree به همراه تردها
![](assets/Screenshot%201402-02-08%20at%2013.34.31.png)

</div>
